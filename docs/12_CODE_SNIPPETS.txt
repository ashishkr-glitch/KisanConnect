CODE SNIPPETS - KISANCONNECT PROJECT

This section provides actual code examples from KisanConnect implementation showing key patterns and technologies used.

=== BACKEND CODE EXAMPLES (Spring Boot / Java) ===

EXAMPLE 1: Authentication Controller with JWT

Location: src/main/java/com/newKisan/auth/AuthenticationController.java

```java
@RestController
@RequestMapping("/api/v1/auth")
@Slf4j
public class AuthenticationController {
    
    @Autowired
    private AuthenticationService authService;
    
    @Autowired
    private JwtTokenProvider jwtTokenProvider;
    
    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody SignupRequest request) {
        try {
            User user = authService.registerUser(request);
            String token = jwtTokenProvider.generateToken(user.getId());
            
            return ResponseEntity.ok(new AuthResponse(
                "User registered successfully",
                token,
                user.getEmail()
            ));
        } catch (Exception e) {
            log.error("Signup failed: {}", e.getMessage());
            return ResponseEntity.badRequest()
                .body(new ErrorResponse("Registration failed", e.getMessage()));
        }
    }
    
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        try {
            User user = authService.authenticateUser(
                request.getEmail(), 
                request.getPassword()
            );
            String token = jwtTokenProvider.generateToken(user.getId());
            
            return ResponseEntity.ok(new AuthResponse(
                "Login successful",
                token,
                user.getEmail()
            ));
        } catch (Exception e) {
            log.error("Login failed: {}", e.getMessage());
            return ResponseEntity.status(401)
                .body(new ErrorResponse("Authentication failed", 
                    "Invalid email or password"));
        }
    }
}
```

EXPLANATION:
- @RestController: Marks class as REST endpoint handler
- @PostMapping: Maps HTTP POST requests
- ResponseEntity: Wraps HTTP response with status codes
- Try-catch block: Handles exceptions and returns appropriate errors
- JwtTokenProvider: Generates secure tokens for stateless authentication
- @Slf4j: Lombok annotation for logging without explicit Logger declaration

---

EXAMPLE 2: Crop Recommendation Service with Strategy Pattern

Location: src/main/java/com/newKisan/crop/CropRecommendationService.java

```java
@Service
@Slf4j
public class CropRecommendationService {
    
    @Autowired
    private CropRepository cropRepository;
    
    @Autowired
    private WeatherService weatherService;
    
    @Autowired
    private UserService userService;
    
    @Cacheable(value = "cropRecommendations", 
               key = "#userId + '-' + #season")
    public List<CropRecommendation> recommendCrops(
            Long userId, 
            String season) {
        
        User user = userService.getUserById(userId);
        Farm farm = user.getFarm();
        Weather weather = weatherService.getCurrentWeather(farm.getLocation());
        
        List<Crop> allCrops = cropRepository.findAll();
        List<CropRecommendation> recommendations = new ArrayList<>();
        
        for (Crop crop : allCrops) {
            double score = calculateSuitabilityScore(crop, farm, weather, season);
            if (score > 60) {
                recommendations.add(new CropRecommendation(crop, score));
            }
        }
        
        // Sort by score descending and take top 5
        return recommendations.stream()
            .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
            .limit(5)
            .collect(Collectors.toList());
    }
    
    private double calculateSuitabilityScore(
            Crop crop, 
            Farm farm, 
            Weather weather, 
            String season) {
        
        double score = 100;
        
        // Climate compatibility
        if (!crop.getClimate().contains(weather.getClimate())) {
            score -= 30;
        }
        
        // Soil compatibility
        if (!crop.getSuitableSoil().contains(farm.getSoilType())) {
            score -= 25;
        }
        
        // Temperature check
        if (weather.getTemperature() > crop.getMaxTemperature() ||
            weather.getTemperature() < crop.getMinTemperature()) {
            score -= 20;
        }
        
        // Rainfall compatibility
        if (weather.getMonthlyRainfall() > crop.getMaxRainfall() ||
            weather.getMonthlyRainfall() < crop.getMinRainfall()) {
            score -= 15;
        }
        
        // Market demand
        score += crop.getMarketDemandScore() * 10;
        
        return Math.max(0, score);
    }
}
```

EXPLANATION:
- @Service: Spring service component for business logic
- @Cacheable: Caches results to avoid recalculation; key = userId + season
- Dependency injection: WeatherService, CropRepository, UserService
- Algorithm: Calculates suitability by checking climate, soil, temperature, rainfall
- Streams API: Sorts and limits recommendations to top 5
- Score deduction: Penalties for incompatibilities, bonuses for market demand

---

EXAMPLE 3: Weather Caching with Scheduled Updates

Location: src/main/java/com/newKisan/weather/WeatherService.java

```java
@Service
@Slf4j
public class WeatherService {
    
    @Autowired
    private WeatherRepository weatherRepository;
    
    @Autowired
    private WeatherAPIProvider weatherAPIProvider;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Cacheable(value = "weather", key = "#location", 
               cacheManager = "weatherCacheManager")
    public Weather getWeatherByLocation(String location) {
        log.debug("Fetching weather for location: {}", location);
        Weather weather = weatherAPIProvider.fetchWeather(location);
        weatherRepository.save(weather);
        return weather;
    }
    
    @Scheduled(fixedDelay = 3600000, initialDelay = 1000) // Every 1 hour
    public void refreshWeatherCache() {
        log.info("Refreshing weather cache...");
        
        List<String> locations = weatherRepository
            .findDistinctLocations();
        
        for (String location : locations) {
            try {
                // Invalidate cache
                Cache cache = cacheManager.getCache("weather");
                if (cache != null) {
                    cache.evict(location);
                }
                // Fetch fresh data
                getWeatherByLocation(location);
                log.debug("Weather updated for location: {}", location);
            } catch (Exception e) {
                log.error("Error refreshing weather for {}: {}", 
                    location, e.getMessage());
            }
        }
    }
    
    public List<Alert> generateWeatherAlerts(String location) {
        Weather weather = getWeatherByLocation(location);
        List<Alert> alerts = new ArrayList<>();
        
        // Check for frost
        if (weather.getTemperature() < 0) {
            alerts.add(new Alert(
                "FROST_WARNING",
                "Temperature below freezing. Protect sensitive crops.",
                AlertLevel.HIGH
            ));
        }
        
        // Check for extreme heat
        if (weather.getTemperature() > 40) {
            alerts.add(new Alert(
                "HEAT_WAVE",
                "High temperature expected. Increase irrigation.",
                AlertLevel.MEDIUM
            ));
        }
        
        // Check for heavy rain
        if (weather.getPrecipitation() > 50) {
            alerts.add(new Alert(
                "HEAVY_RAIN",
                "Significant rainfall. Monitor soil waterlogging.",
                AlertLevel.MEDIUM
            ));
        }
        
        return alerts;
    }
}
```

EXPLANATION:
- @Scheduled: Runs method periodically (every 1 hour)
- Cache invalidation: Evicts old cache before fetching fresh data
- Error handling: Catches and logs errors without breaking cache refresh
- Alert generation: Checks weather conditions against thresholds
- Caching strategy: Reduces API calls, improves performance

---

EXAMPLE 4: Global Exception Handler (Aspect-Oriented Programming)

Location: src/main/java/com/newKisan/common/GlobalExceptionHandler.java

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(
            UserNotFoundException ex) {
        log.warn("User not found: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(
                "User Not Found",
                ex.getMessage()
            ));
    }
    
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorized(
            UnauthorizedException ex) {
        log.warn("Unauthorized access: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .body(new ErrorResponse(
                "Unauthorized",
                "You do not have permission to access this resource"
            ));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex) {
        log.error("Unexpected error: {}", ex.getMessage(), ex);
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse(
                "Internal Server Error",
                "An unexpected error occurred. Please try again later."
            ));
    }
    
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDatabaseError(
            DataIntegrityViolationException ex) {
        log.error("Database error: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(new ErrorResponse(
                "Database Error",
                "Data integrity violation. Please check your input."
            ));
    }
}
```

EXPLANATION:
- @RestControllerAdvice: Global exception handler for all controllers
- @ExceptionHandler: Maps specific exceptions to HTTP responses
- Different status codes: 404 (Not Found), 401 (Unauthorized), 500 (Server Error)
- Logging at appropriate levels: warn for client errors, error for server errors
- Consistent error response format for client error handling

---

=== FRONTEND CODE EXAMPLES (React / JavaScript) ===

EXAMPLE 5: Custom Hook for Authentication Context

Location: src/hooks/useAuth.js

```javascript
import { createContext, useContext, useState, useEffect } from 'react';
import { auth } from '../firebase';
import { onAuthStateChanged, signOut } from 'firebase/auth';
import axios from 'axios';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      try {
        if (firebaseUser) {
          const idToken = await firebaseUser.getIdToken();
          setToken(idToken);
          
          // Store token in localStorage
          localStorage.setItem('authToken', idToken);
          
          // Set default axios header
          axios.defaults.headers.common['Authorization'] = 
            `Bearer ${idToken}`;
          
          // Fetch user details from backend
          const response = await axios.get('/api/v1/user/profile');
          setUser({
            ...firebaseUser,
            farmDetails: response.data
          });
        } else {
          setUser(null);
          setToken(null);
          localStorage.removeItem('authToken');
          delete axios.defaults.headers.common['Authorization'];
        }
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    });

    return unsubscribe;
  }, []);

  const logout = async () => {
    try {
      await signOut(auth);
      setUser(null);
      setToken(null);
    } catch (err) {
      setError('Logout failed: ' + err.message);
    }
  };

  return (
    <AuthContext.Provider value={{ user, token, loading, error, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

EXPLANATION:
- React Context API: Manages authentication state globally
- Custom Hook: useAuth() provides easy access to auth state
- Firebase Integration: Monitors auth state changes
- Token Management: Stores JWT token in localStorage and axios headers
- Error Handling: Catches and exposes authentication errors
- Cleanup: Unsubscribes from auth listener on component unmount

---

EXAMPLE 6: Manifest Component with State Management

Location: src/components/ManifestComponent.js

```javascript
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './ManifestComponent.css';
import { useAuth } from '../hooks/useAuth';

const ManifestComponent = ({ cropId }) => {
  const [manifest, setManifest] = useState(null);
  const [tasks, setTasks] = useState([]);
  const [formData, setFormData] = useState({
    plantingDate: '',
    expectedHarvestDate: '',
    targetYield: '',
    taskDescription: '',
    taskDate: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { token } = useAuth();

  // Fetch existing manifest
  useEffect(() => {
    const fetchManifest = async () => {
      try {
        setLoading(true);
        const response = await axios.get(
          `/api/v1/manifest/crop/${cropId}`,
          { headers: { 'Authorization': `Bearer ${token}` } }
        );
        setManifest(response.data);
        setTasks(response.data.tasks || []);
      } catch (err) {
        setError('Failed to load manifest: ' + err.message);
      } finally {
        setLoading(false);
      }
    };

    if (cropId && token) {
      fetchManifest();
    }
  }, [cropId, token]);

  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Create or update manifest
  const handleSaveManifest = async () => {
    try {
      setLoading(true);
      setError(null);

      const payload = {
        cropId,
        plantingDate: new Date(formData.plantingDate).toISOString(),
        expectedHarvestDate: new Date(formData.expectedHarvestDate).toISOString(),
        targetYield: parseFloat(formData.targetYield)
      };

      const response = manifest
        ? await axios.put(
            `/api/v1/manifest/${manifest.id}`,
            payload,
            { headers: { 'Authorization': `Bearer ${token}` } }
          )
        : await axios.post(
            `/api/v1/manifest`,
            payload,
            { headers: { 'Authorization': `Bearer ${token}` } }
          );

      setManifest(response.data);
      alert('Manifest saved successfully!');
    } catch (err) {
      setError('Error saving manifest: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  // Add task to manifest
  const handleAddTask = async () => {
    try {
      if (!manifest) {
        setError('Please save manifest first');
        return;
      }

      const taskPayload = {
        manifestId: manifest.id,
        description: formData.taskDescription,
        scheduledDate: new Date(formData.taskDate).toISOString(),
        status: 'PENDING'
      };

      const response = await axios.post(
        `/api/v1/manifest/task`,
        taskPayload,
        { headers: { 'Authorization': `Bearer ${token}` } }
      );

      setTasks([...tasks, response.data]);
      setFormData(prev => ({
        ...prev,
        taskDescription: '',
        taskDate: ''
      }));
    } catch (err) {
      setError('Error adding task: ' + err.message);
    }
  };

  // Mark task as complete
  const handleCompleteTask = async (taskId) => {
    try {
      const response = await axios.patch(
        `/api/v1/manifest/task/${taskId}/complete`,
        {},
        { headers: { 'Authorization': `Bearer ${token}` } }
      );

      setTasks(tasks.map(t => t.id === taskId ? response.data : t));
    } catch (err) {
      setError('Error updating task: ' + err.message);
    }
  };

  if (loading) return <div className="loading">Loading manifest...</div>;

  return (
    <div className="manifest-container">
      <h2>Crop Manifest Plan</h2>
      
      {error && <div className="error-message">{error}</div>}

      <section className="manifest-details">
        <div className="form-group">
          <label>Planting Date:</label>
          <input
            type="date"
            name="plantingDate"
            value={formData.plantingDate}
            onChange={handleInputChange}
          />
        </div>

        <div className="form-group">
          <label>Expected Harvest Date:</label>
          <input
            type="date"
            name="expectedHarvestDate"
            value={formData.expectedHarvestDate}
            onChange={handleInputChange}
          />
        </div>

        <div className="form-group">
          <label>Target Yield (units):</label>
          <input
            type="number"
            name="targetYield"
            value={formData.targetYield}
            onChange={handleInputChange}
          />
        </div>

        <button 
          onClick={handleSaveManifest} 
          disabled={loading}
          className="btn-primary"
        >
          {manifest ? 'Update Manifest' : 'Create Manifest'}
        </button>
      </section>

      <section className="tasks-section">
        <h3>Tasks</h3>
        
        <div className="add-task-form">
          <input
            type="text"
            placeholder="Task description"
            name="taskDescription"
            value={formData.taskDescription}
            onChange={handleInputChange}
          />
          <input
            type="date"
            name="taskDate"
            value={formData.taskDate}
            onChange={handleInputChange}
          />
          <button 
            onClick={handleAddTask}
            className="btn-secondary"
          >
            Add Task
          </button>
        </div>

        <ul className="tasks-list">
          {tasks.map(task => (
            <li key={task.id} className={`task-item ${task.status}`}>
              <div className="task-info">
                <strong>{task.description}</strong>
                <span className="task-date">
                  {new Date(task.scheduledDate).toLocaleDateString()}
                </span>
              </div>
              <button
                onClick={() => handleCompleteTask(task.id)}
                disabled={task.status === 'COMPLETED'}
                className="btn-complete"
              >
                {task.status === 'COMPLETED' ? 'Done' : 'Complete'}
              </button>
            </li>
          ))}
        </ul>
      </section>
    </div>
  );
};

export default ManifestComponent;
```

EXPLANATION:
- useState: Manages component state (manifest, tasks, form data)
- useEffect: Fetches data on component mount and when cropId changes
- Async/await: Handles API calls cleanly
- Error handling: Displays errors to user
- Conditional rendering: Shows different UI states (loading, error, success)
- Optimistic updates: Updates local state immediately after API call
- Token management: Passes JWT token in every request header
- CRUD operations: Create, Read (fetch), Update, Delete tasks

---

EXAMPLE 7: Weather Forecast Chart Component

Location: src/components/WeatherChart.js

```javascript
import React, { useState, useEffect } from 'react';
import { Line, Bar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler
} from 'chart.js';
import axios from 'axios';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

const WeatherChart = ({ location }) => {
  const [chartData, setChartData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchWeatherData = async () => {
      try {
        const response = await axios.get(
          `/api/v1/weather/forecast/${location}`
        );
        
        const forecast = response.data.forecast;
        
        // Prepare labels (dates)
        const labels = forecast.map(day => 
          new Date(day.date).toLocaleDateString('en-US', 
            { month: 'short', day: 'numeric' })
        );

        // Prepare temperature data
        const tempData = {
          labels,
          datasets: [
            {
              label: 'Max Temperature (°C)',
              data: forecast.map(day => day.maxTemp),
              borderColor: '#FF6384',
              backgroundColor: 'rgba(255, 99, 132, 0.1)',
              fill: true,
              borderWidth: 2,
              tension: 0.4
            },
            {
              label: 'Min Temperature (°C)',
              data: forecast.map(day => day.minTemp),
              borderColor: '#36A2EB',
              backgroundColor: 'rgba(54, 162, 235, 0.1)',
              fill: true,
              borderWidth: 2,
              tension: 0.4
            }
          ]
        };

        // Prepare precipitation data
        const precipData = {
          labels,
          datasets: [
            {
              label: 'Rainfall (mm)',
              data: forecast.map(day => day.rainfall),
              backgroundColor: '#4BC0C0',
              borderColor: '#1AA39A',
              borderWidth: 1
            }
          ]
        };

        setChartData({ tempData, precipData });
      } catch (error) {
        console.error('Error fetching weather data:', error);
      } finally {
        setLoading(false);
      }
    };

    if (location) {
      fetchWeatherData();
    }
  }, [location]);

  if (loading) return <div>Loading weather chart...</div>;

  return (
    <div className="weather-charts">
      <div className="chart-container">
        <h3>Temperature Forecast</h3>
        {chartData && (
          <Line 
            data={chartData.tempData}
            options={{
              responsive: true,
              plugins: {
                legend: {
                  position: 'top',
                },
                title: {
                  display: true,
                  text: '7-Day Temperature Forecast'
                }
              },
              scales: {
                y: {
                  title: {
                    display: true,
                    text: 'Temperature (°C)'
                  }
                }
              }
            }}
          />
        )}
      </div>

      <div className="chart-container">
        <h3>Rainfall Forecast</h3>
        {chartData && (
          <Bar 
            data={chartData.precipData}
            options={{
              responsive: true,
              plugins: {
                legend: {
                  position: 'top',
                },
                title: {
                  display: true,
                  text: '7-Day Rainfall Forecast'
                }
              },
              scales: {
                y: {
                  title: {
                    display: true,
                    text: 'Rainfall (mm)'
                  }
                }
              }
            }}
          />
        )}
      </div>
    </div>
  );
};

export default WeatherChart;
```

EXPLANATION:
- Chart.js library: Industry-standard charting with React wrapper
- useEffect: Fetches forecast data on component mount
- Data transformation: Converts API response to Chart.js format
- Responsive design: Charts adapt to container size
- Multiple datasets: Shows multiple weather metrics simultaneously
- Customization: Legend, title, scales configured for clarity

---

This code demonstrates key patterns used throughout KisanConnect:
- Proper error handling and user feedback
- State management with React hooks
- Secure JWT authentication
- Caching and performance optimization
- Responsive UI components
- Integration with external APIs

-- End of Code Snippets
